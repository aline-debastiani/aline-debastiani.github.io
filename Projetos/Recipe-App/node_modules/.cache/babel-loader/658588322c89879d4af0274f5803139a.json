{"ast":null,"code":"import React,{useEffect}from'react';import{useDispatch,useSelector}from'react-redux';import{useHistory}from'react-router';import{Alert}from'react-bootstrap';import RecipeCard from'../components/RecipeCard';import Loading from'../components/Loading';import CategoryButton from'../components/CategoryButton';import Header from'../components/Header';import Footer from'../components/Footer';import{byAddIngredient,fetchCategories,fetchRecipes}from'../actions/recipes';import'bootstrap/dist/css/bootstrap.min.css';import'./Main.css';function Main(_ref){var pathname=_ref.location.pathname;var _useSelector=useSelector(function(state){return state.recipes;}),list=_useSelector.list,isFetching=_useSelector.isFetching,categories=_useSelector.categories,byIngredient=_useSelector.byIngredient,filter=_useSelector.filter;var dispatch=useDispatch();var history=useHistory();var type=pathname.slice(1);var _useSelector2=useSelector(function(state){return state.login;}),mealsToken=_useSelector2.mealsToken,cocktailsToken=_useSelector2.cocktailsToken;var renderRecipes=function renderRecipes(){if(list.length===0){alert('Sinto muito, não encontramos nenhuma receita para esses filtros.');return/*#__PURE__*/React.createElement(Alert,{style:{marginTop:'20px'},variant:\"danger\"},Date.now()%2===0?/*#__PURE__*/React.createElement(Alert.Heading,null,\"Uai...\"):/*#__PURE__*/React.createElement(Alert.Heading,null,\"Oxi...\"),/*#__PURE__*/React.createElement(\"p\",null,\"Redefina o campo de busca.\"));}if(list.length===1&&filter===''){history.push(\"\".concat(pathname,\"/\").concat(list[0].id));return;}return/*#__PURE__*/React.createElement(\"section\",{className:\"cards-container\"},list.map(function(recipe,index){return/*#__PURE__*/React.createElement(\"div\",{className:\"cards-main\",key:\"recipe-\".concat(index)},/*#__PURE__*/React.createElement(RecipeCard,{type:type,index:index,recipe:recipe}));}));};useEffect(function(){var reqType={request:'filter',key:'i',parameter:byIngredient};var token=pathname==='comidas'?mealsToken:cocktailsToken;dispatch(fetchCategories(token,type));if(byIngredient){dispatch(fetchRecipes(token,type,reqType));dispatch(byAddIngredient(''));}else{dispatch(fetchRecipes(token,type));}},[pathname]);return/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(Header,null),/*#__PURE__*/React.createElement(\"nav\",{className:\"nav-catogories\"},categories.map(function(category){return/*#__PURE__*/React.createElement(CategoryButton,{name:category,key:\"btn-\".concat(category),type:type});}),/*#__PURE__*/React.createElement(CategoryButton,{name:\"All\",type:type})),isFetching?/*#__PURE__*/React.createElement(Loading,null):renderRecipes(),/*#__PURE__*/React.createElement(Footer,null));}export default Main;","map":{"version":3,"sources":["/home/alinedebastiani/sd-08-project-recipes-app/src/pages/Main.jsx"],"names":["React","useEffect","useDispatch","useSelector","useHistory","Alert","RecipeCard","Loading","CategoryButton","Header","Footer","byAddIngredient","fetchCategories","fetchRecipes","Main","pathname","location","state","recipes","list","isFetching","categories","byIngredient","filter","dispatch","history","type","slice","login","mealsToken","cocktailsToken","renderRecipes","length","alert","marginTop","Date","now","push","id","map","recipe","index","reqType","request","key","parameter","token","category"],"mappings":"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","sourcesContent":["import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useHistory } from 'react-router';\nimport { Alert } from 'react-bootstrap';\nimport RecipeCard from '../components/RecipeCard';\nimport Loading from '../components/Loading';\nimport CategoryButton from '../components/CategoryButton';\nimport Header from '../components/Header';\nimport Footer from '../components/Footer';\nimport { byAddIngredient, fetchCategories, fetchRecipes } from '../actions/recipes';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './Main.css';\n\nfunction Main({ location: { pathname } }) {\n  const {\n    list, isFetching, categories, byIngredient, filter,\n  } = useSelector((state) => state.recipes);\n  const dispatch = useDispatch();\n  const history = useHistory();\n  const type = pathname.slice(1);\n  const { mealsToken, cocktailsToken } = useSelector((state) => state.login);\n\n  const renderRecipes = () => {\n    if (list.length === 0) {\n      alert('Sinto muito, não encontramos nenhuma receita para esses filtros.');\n      return (\n        <Alert style={ { marginTop: '20px' } } variant=\"danger\">\n          {\n            (Date.now() % 2 === 0)\n              ? <Alert.Heading>Uai...</Alert.Heading>\n              : <Alert.Heading>Oxi...</Alert.Heading>\n          }\n          <p>Redefina o campo de busca.</p>\n        </Alert>\n      );\n    }\n    if (list.length === 1 && filter === '') {\n      history.push(`${pathname}/${list[0].id}`);\n      return;\n    }\n    return (\n      <section className=\"cards-container\">\n        {list.map((recipe, index) => (\n          <div className=\"cards-main\" key={ `recipe-${index}` }>\n            <RecipeCard\n              type={ type }\n              index={ index }\n              recipe={ recipe }\n            />\n          </div>\n        ))}\n      </section>\n    );\n  };\n\n  useEffect(() => {\n    const reqType = { request: 'filter', key: 'i', parameter: byIngredient };\n    const token = pathname === 'comidas' ? mealsToken : cocktailsToken;\n    dispatch(fetchCategories(token, type));\n    if (byIngredient) {\n      dispatch(fetchRecipes(token, type, reqType));\n      dispatch(byAddIngredient(''));\n    } else {\n      dispatch(fetchRecipes(token, type));\n    }\n  }, [pathname]);\n\n  return (\n    <>\n      <Header />\n      <nav className=\"nav-catogories\">\n        { categories\n          .map((category) => (\n            <CategoryButton\n              name={ category }\n              key={ `btn-${category}` }\n              type={ type }\n            />))}\n        <CategoryButton name=\"All\" type={ type } />\n      </nav>\n      { isFetching ? <Loading /> : renderRecipes() }\n      <Footer />\n    </>\n  );\n}\n\nMain.propTypes = {\n  location: PropTypes.shape({\n    pathname: PropTypes.string.isRequired,\n  }).isRequired,\n};\n\nexport default Main;\n"]},"metadata":{},"sourceType":"module"}